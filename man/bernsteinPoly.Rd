% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bernsteinPoly.R
\name{bernsteinPoly}
\alias{bernsteinPoly}
\title{Generalized Bernstein Polynomial Basis}
\usage{
bernsteinPoly(
  x,
  degree = 3,
  derivs = 0L,
  integral = FALSE,
  intercept = FALSE,
  Boundary.knots = c(0, 1),
  ...
)
}
\arguments{
\item{x}{The predictor variable taking values between 0 and 1.  Missing
values are allowed and will be returned as they are.}

\item{degree}{A non-negative integer representing the degree of the
polynomials.}

\item{derivs}{A non-negative integer specifying the order of derivatives.
The default value is \code{0L} for Bernstein polynomial bases.}

\item{integral}{A logical value.  If \code{TRUE}, the integrals of the
Bernstein polynomials will be returned.  The default value is
\code{FALSE}.}

\item{intercept}{If \code{TRUE}, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output.}

\item{Boundary.knots}{Boundary points at which to anchor the Bernstein
polynomial basis. The default value is \code{c(0, 1)} for original
Bernstein polynomial basis over [0, 1].}

\item{...}{Optional arguments that are not used.}
}
\value{
A numeric matrix of dimension \code{length(x)} by \code{degree +
    as.integer(intercept)}.
}
\description{
Returns a generalized Bernstein polynomial basis matrix of given degree over
a specified range.
}
\examples{
library(splines2)

x <- seq(0, 1, 0.1)
## Bernstein polynomial basis matrix
bMat <- bernsteinPoly(x, degree = 4, intercept = TRUE)

## the first and second derivative matrix
d1Mat <- bernsteinPoly(x, degree = 4, derivs = 1, intercept = TRUE)
d2Mat <- bernsteinPoly(x, degree = 4, derivs = 2, intercept = TRUE)
## or use the deriv method
all.equal(d1Mat, deriv(bMat))
all.equal(d2Mat, deriv(bMat, 2))

## the integral matrix
iMat <- bernsteinPoly(x, degree = 4, integral = TRUE, intercept = TRUE)
all.equal(deriv(iMat), bMat, check.attributes = FALSE)
}
